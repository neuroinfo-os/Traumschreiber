works:
	fetching AD data
		from all 3 AD's in parallel
		in 32 Byte packets each
		if data from all 3 is there and send buffer has space: try to filter/encode, write to send buffer and then send
	sending via BLE
		packages are (by default) distributed over three characteristics
		only fetching/sending if other device is connected and has enabled notifications on all three characteristics (both nicely triggered on BLE-events)
		in 20 Byte packets
		trying to send on each recieved AD packet
			buffer-full check is now dirty (just checks if there is at least 20 packets read capacity plus new package and ignores write capacity)
	filtering
		biquad cascade IIR filters from arm_math package for M4
			two instances per channel
				high pass, low pass and notch
				coefficients (and order) are configurable via config characteristic
		turned on by default, circumvented if dummy data is transmitted
	encoding
		put all 24 channels in 1.5 packages as difference (dcpm) values with 10Bit each
			values are shifted (aka least significant Bits are dropped) according to current variance
			amount of shifting is pushed out via 'C0DE' characteristic every second data points as notification
				also includes, how many packages have been dropped since the last C0DE update
	dummy data generation
		can be toggeled via config characteristic (see below)
		data gets generated every time a sample from the ADs come in
		it is possible to have generated and sampled data (see below)
		only generates 8 channels anyways
	battery reading
		works now
		AUXAIN register of AD1 (of 0-2) is read and written into byte 3&4 of config characteristic
		happens at startup and if notifications are disabled on one characteristic (of 4)
	configuration characteristic (4 Bytes total)
		1st Byte:
			xxoo oooo: gain (00: 1, 01: 2, 10: 4, 11:8)
			ooxo oooo: generate data (0: off, 1: on), this disables/enables filtering (no filtering with dummy data)
			ooox oooo: if set, replace half of the generated data by real data (only works together with the option above, obviously)
			oooo xooo: if set, battery status is aquired and written in the following two Bytes. currently dummy data (0x102) is written, because there is a bug still. this bit is then unset by Traumschreiber.
			oooo oxoo: if set, data is only send via first characteristic
			oooo ooxo: if set, enables high pass filter
			oooo ooox: if set, enables average calculation/subtraction
		2nd Byte:
			//xxxx oooo: encoding factor (0 resets to default (8?)
			xxxx oooo: switching between filter sets
				0: FolterCoeff_Notch_fs500_L48_H52_O8 (default)
				1: FolterCoeff_Notch_fs500_L45_H55_O4
				2: FolterCoeff_Notch_fs500_L45_H55_O6
				3: FolterCoeff_Notch_fs500_L47_H53_O4
				4: FolterCoeff_Notch_fs500_L47_H53_O6
				5: FolterCoeff_Notch_fs500_L48_H52_O4
				6: FolterCoeff_Notch_fs500_L48_H52_O6
				7: FolterCoeff_Notch_fs500_L46_H54_O6
				8-15: same as 0-7 above but FolterCoeff_LowPass_fs500_L73.3333_O8 is used for low pass (0-7 use the default FolterCoeff_LowPass_fs500_L43.3333_O6)
			reserved
		3rd and 4th Byte: debug/controll data. for example battery status.
		
		
constraints:
	datarate: sampled down from 500 to 167Hz
		still 250Hz of packages is send
error output
	LED 18 is turned on when a packet is dropped internally and turned off again when one is succesfully cued
	LED 20 is turned on when AD0 is signalling available data und turned on once internal processing starts (after SPI transfer). 
	
